//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace EmuliciousDebuggerPackage
{
    
    
    internal partial class EmuliciousDebugger
    {
        
        /// <summary>Backing field for deserialized rule.<see cref='Microsoft.Build.Framework.XamlTypes.Rule'/>.</summary>
        private static Microsoft.Build.Framework.XamlTypes.Rule deserializedFallbackRule;
        
        /// <summary>The name of the schema to look for at runtime to fulfill property access.</summary>
        internal const string SchemaName = "EmuliciousDebugger";
        
        /// <summary>The ItemType given in the Rule.DataSource property.  May not apply to every Property's individual DataSource.</summary>
        internal const string PrimaryDataSourceItemType = null;
        
        /// <summary>The Label given in the Rule.DataSource property.  May not apply to every Property's individual DataSource.</summary>
        internal const string PrimaryDataSourceLabel = "";
        
        /// <summary>The path to the Emulicious Executable. (The "EmuliciousDebuggerExecutable" property).</summary>
        internal const string EmuliciousDebuggerExecutableProperty = "EmuliciousDebuggerExecutable";
        
        /// <summary>The full path to the emulicious rom. (The "EmuliciousLaunchRom" property).</summary>
        internal const string EmuliciousLaunchRomProperty = "EmuliciousLaunchRom";
        
        /// <summary>Specifies whether the debugger should attempt to attach to an existing process when debugging starts. (The "EmuliciousDebuggerDebuggerAttach" property).</summary>
        internal const string EmuliciousDebuggerDebuggerAttachProperty = "EmuliciousDebuggerDebuggerAttach";
        
        /// <summary>Specifies if the debugger will break on startup. (The "EmuliciousDebuggerDebuggerStopOnEntry" property).</summary>
        internal const string EmuliciousDebuggerDebuggerStopOnEntryProperty = "EmuliciousDebuggerDebuggerStopOnEntry";
        
        /// <summary>Emulicious debugger communication port. (The "EmuliciousDebuggerPort" property).</summary>
        internal const string EmuliciousDebuggerPortProperty = "EmuliciousDebuggerPort";
        
        /// <summary>Emulicious debugger startup launch delay port. (The "EmuliciousDebuggerStartDelay" property).</summary>
        internal const string EmuliciousDebuggerStartDelayProperty = "EmuliciousDebuggerStartDelay";
        
        /// <summary>Path to save the debugger communication log file. (The "EmuliciousDebugLogPath" property).</summary>
        internal const string EmuliciousDebugLogPathProperty = "EmuliciousDebugLogPath";
        
        /// <summary>Paths to expose to emulicious for debugging source files. (The "EmuliciousSourcePaths" property).</summary>
        internal const string EmuliciousSourcePathsProperty = "EmuliciousSourcePaths";
        
        /// <summary>Passes the '-remotedebug <port>' argument to emulicious to enable remote debugging without manual configuration. (The "EmuliciousRemoteDebugArgument" property).</summary>
        internal const string EmuliciousRemoteDebugArgumentProperty = "EmuliciousRemoteDebugArgument";
        
        /// <summary>Uses symlink's relative to the rom path to map all the 'Source Folder Paths'. (The "EmuliciousLegacySourceFolders" property).</summary>
        internal const string EmuliciousLegacySourceFoldersProperty = "EmuliciousLegacySourceFolders";
        
        /// <summary>Injects breakpoint line information if it is not provided in breakpoint response messages. (The "EmuliciousLegacyBreakpointFix" property).</summary>
        internal const string EmuliciousLegacyBreakpointFixProperty = "EmuliciousLegacyBreakpointFix";
        
        /// <summary>Backing field for the <see cref='Microsoft.Build.Framework.XamlTypes.Rule'/> property.</summary>
        private Microsoft.VisualStudio.ProjectSystem.Properties.IRule rule;
        
        /// <summary>Backing field for the file name of the rule property.</summary>
        private string file;
        
        /// <summary>Backing field for the ItemType property.</summary>
        private string itemType;
        
        /// <summary>Backing field for the ItemName property.</summary>
        private string itemName;
        
        /// <summary>Configured Project</summary>
        private Microsoft.VisualStudio.ProjectSystem.ConfiguredProject configuredProject;
        
        /// <summary>The dictionary of named catalogs.</summary>
        private System.Collections.Immutable.IImmutableDictionary<string, Microsoft.VisualStudio.ProjectSystem.Properties.IPropertyPagesCatalog> catalogs;
        
        /// <summary>Backing field for the <see cref='Microsoft.VisualStudio.ProjectSystem.Properties.IRule'/> property.</summary>
        private Microsoft.VisualStudio.ProjectSystem.Properties.IRule fallbackRule;
        
        /// <summary>Thread locking object</summary>
        private object locker = new object();
        
        /// <summary>Initializes a new instance of the EmuliciousDebugger class.</summary>
        internal EmuliciousDebugger(Microsoft.VisualStudio.ProjectSystem.Properties.IRule rule)
        {
            this.rule = rule;
        }
        
        /// <summary>Initializes a new instance of the EmuliciousDebugger class.</summary>
        internal EmuliciousDebugger(Microsoft.VisualStudio.ProjectSystem.ConfiguredProject configuredProject, System.Collections.Immutable.IImmutableDictionary<string, Microsoft.VisualStudio.ProjectSystem.Properties.IPropertyPagesCatalog> catalogs, string context, string file, string itemType, string itemName) : 
                this(GetRule(System.Collections.Immutable.ImmutableDictionary.GetValueOrDefault(catalogs, context), file, itemType, itemName))
        {
            if ((configuredProject == null))
            {
                throw new System.ArgumentNullException("configuredProject");
            }
            this.configuredProject = configuredProject;
            this.catalogs = catalogs;
            this.file = file;
            this.itemType = itemType;
            this.itemName = itemName;
        }
        
        /// <summary>Initializes a new instance of the EmuliciousDebugger class.</summary>
        internal EmuliciousDebugger(Microsoft.VisualStudio.ProjectSystem.Properties.IRule rule, Microsoft.VisualStudio.ProjectSystem.ConfiguredProject configuredProject) : 
                this(rule)
        {
            if ((rule == null))
            {
                throw new System.ArgumentNullException("rule");
            }
            if ((configuredProject == null))
            {
                throw new System.ArgumentNullException("configuredProject");
            }
            this.configuredProject = configuredProject;
            this.rule = rule;
            this.file = this.rule.File;
            this.itemType = this.rule.ItemType;
            this.itemName = this.rule.ItemName;
        }
        
        /// <summary>Initializes a new instance of the EmuliciousDebugger class.</summary>
        internal EmuliciousDebugger(Microsoft.VisualStudio.ProjectSystem.ConfiguredProject configuredProject, System.Collections.Immutable.IImmutableDictionary<string, Microsoft.VisualStudio.ProjectSystem.Properties.IPropertyPagesCatalog> catalogs, string context, Microsoft.VisualStudio.ProjectSystem.Properties.IProjectPropertiesContext propertyContext) : 
                this(configuredProject, catalogs, context, GetContextFile(propertyContext), propertyContext.ItemType, propertyContext.ItemName)
        {
        }
        
        /// <summary>Initializes a new instance of the EmuliciousDebugger class that assumes a project context (neither property sheet nor items).</summary>
        internal EmuliciousDebugger(Microsoft.VisualStudio.ProjectSystem.ConfiguredProject configuredProject, System.Collections.Immutable.IImmutableDictionary<string, Microsoft.VisualStudio.ProjectSystem.Properties.IPropertyPagesCatalog> catalogs) : 
                this(configuredProject, catalogs, "Project", null, null, null)
        {
        }
        
        /// <summary>Gets the IRule used to get and set properties.</summary>
        public Microsoft.VisualStudio.ProjectSystem.Properties.IRule Rule
        {
            get
            {
                return this.rule;
            }
        }
        
        /// <summary>The path to the Emulicious Executable.</summary>
        internal Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty EmuliciousDebuggerExecutable
        {
            get
            {
                Microsoft.VisualStudio.ProjectSystem.Properties.IRule localRule = this.rule;
                if ((localRule == null))
                {
                    localRule = this.GeneratedFallbackRule;
                }
                if ((localRule == null))
                {
                    return null;
                }
                Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty property = ((Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty)(localRule.GetProperty(EmuliciousDebuggerExecutableProperty)));
                if (((property == null) 
                            && (this.GeneratedFallbackRule != null)))
                {
                    localRule = this.GeneratedFallbackRule;
                    property = ((Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty)(localRule.GetProperty(EmuliciousDebuggerExecutableProperty)));
                }
                return property;
            }
        }
        
        /// <summary>The full path to the emulicious rom.</summary>
        internal Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty EmuliciousLaunchRom
        {
            get
            {
                Microsoft.VisualStudio.ProjectSystem.Properties.IRule localRule = this.rule;
                if ((localRule == null))
                {
                    localRule = this.GeneratedFallbackRule;
                }
                if ((localRule == null))
                {
                    return null;
                }
                Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty property = ((Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty)(localRule.GetProperty(EmuliciousLaunchRomProperty)));
                if (((property == null) 
                            && (this.GeneratedFallbackRule != null)))
                {
                    localRule = this.GeneratedFallbackRule;
                    property = ((Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty)(localRule.GetProperty(EmuliciousLaunchRomProperty)));
                }
                return property;
            }
        }
        
        /// <summary>Specifies whether the debugger should attempt to attach to an existing process when debugging starts.</summary>
        internal Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty EmuliciousDebuggerDebuggerAttach
        {
            get
            {
                Microsoft.VisualStudio.ProjectSystem.Properties.IRule localRule = this.rule;
                if ((localRule == null))
                {
                    localRule = this.GeneratedFallbackRule;
                }
                if ((localRule == null))
                {
                    return null;
                }
                Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty property = ((Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty)(localRule.GetProperty(EmuliciousDebuggerDebuggerAttachProperty)));
                if (((property == null) 
                            && (this.GeneratedFallbackRule != null)))
                {
                    localRule = this.GeneratedFallbackRule;
                    property = ((Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty)(localRule.GetProperty(EmuliciousDebuggerDebuggerAttachProperty)));
                }
                return property;
            }
        }
        
        /// <summary>Specifies if the debugger will break on startup.</summary>
        internal Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty EmuliciousDebuggerDebuggerStopOnEntry
        {
            get
            {
                Microsoft.VisualStudio.ProjectSystem.Properties.IRule localRule = this.rule;
                if ((localRule == null))
                {
                    localRule = this.GeneratedFallbackRule;
                }
                if ((localRule == null))
                {
                    return null;
                }
                Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty property = ((Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty)(localRule.GetProperty(EmuliciousDebuggerDebuggerStopOnEntryProperty)));
                if (((property == null) 
                            && (this.GeneratedFallbackRule != null)))
                {
                    localRule = this.GeneratedFallbackRule;
                    property = ((Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty)(localRule.GetProperty(EmuliciousDebuggerDebuggerStopOnEntryProperty)));
                }
                return property;
            }
        }
        
        /// <summary>Emulicious debugger communication port.</summary>
        internal Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty EmuliciousDebuggerPort
        {
            get
            {
                Microsoft.VisualStudio.ProjectSystem.Properties.IRule localRule = this.rule;
                if ((localRule == null))
                {
                    localRule = this.GeneratedFallbackRule;
                }
                if ((localRule == null))
                {
                    return null;
                }
                Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty property = ((Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty)(localRule.GetProperty(EmuliciousDebuggerPortProperty)));
                if (((property == null) 
                            && (this.GeneratedFallbackRule != null)))
                {
                    localRule = this.GeneratedFallbackRule;
                    property = ((Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty)(localRule.GetProperty(EmuliciousDebuggerPortProperty)));
                }
                return property;
            }
        }
        
        /// <summary>Emulicious debugger startup launch delay port.</summary>
        internal Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty EmuliciousDebuggerStartDelay
        {
            get
            {
                Microsoft.VisualStudio.ProjectSystem.Properties.IRule localRule = this.rule;
                if ((localRule == null))
                {
                    localRule = this.GeneratedFallbackRule;
                }
                if ((localRule == null))
                {
                    return null;
                }
                Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty property = ((Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty)(localRule.GetProperty(EmuliciousDebuggerStartDelayProperty)));
                if (((property == null) 
                            && (this.GeneratedFallbackRule != null)))
                {
                    localRule = this.GeneratedFallbackRule;
                    property = ((Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty)(localRule.GetProperty(EmuliciousDebuggerStartDelayProperty)));
                }
                return property;
            }
        }
        
        /// <summary>Path to save the debugger communication log file.</summary>
        internal Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty EmuliciousDebugLogPath
        {
            get
            {
                Microsoft.VisualStudio.ProjectSystem.Properties.IRule localRule = this.rule;
                if ((localRule == null))
                {
                    localRule = this.GeneratedFallbackRule;
                }
                if ((localRule == null))
                {
                    return null;
                }
                Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty property = ((Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty)(localRule.GetProperty(EmuliciousDebugLogPathProperty)));
                if (((property == null) 
                            && (this.GeneratedFallbackRule != null)))
                {
                    localRule = this.GeneratedFallbackRule;
                    property = ((Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty)(localRule.GetProperty(EmuliciousDebugLogPathProperty)));
                }
                return property;
            }
        }
        
        /// <summary>Paths to expose to emulicious for debugging source files.</summary>
        internal Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty EmuliciousSourcePaths
        {
            get
            {
                Microsoft.VisualStudio.ProjectSystem.Properties.IRule localRule = this.rule;
                if ((localRule == null))
                {
                    localRule = this.GeneratedFallbackRule;
                }
                if ((localRule == null))
                {
                    return null;
                }
                Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty property = ((Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty)(localRule.GetProperty(EmuliciousSourcePathsProperty)));
                if (((property == null) 
                            && (this.GeneratedFallbackRule != null)))
                {
                    localRule = this.GeneratedFallbackRule;
                    property = ((Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty)(localRule.GetProperty(EmuliciousSourcePathsProperty)));
                }
                return property;
            }
        }
        
        /// <summary>Passes the &apos;-remotedebug &lt;port&gt;&apos; argument to emulicious to enable remote debugging without manual configuration.</summary>
        internal Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty EmuliciousRemoteDebugArgument
        {
            get
            {
                Microsoft.VisualStudio.ProjectSystem.Properties.IRule localRule = this.rule;
                if ((localRule == null))
                {
                    localRule = this.GeneratedFallbackRule;
                }
                if ((localRule == null))
                {
                    return null;
                }
                Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty property = ((Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty)(localRule.GetProperty(EmuliciousRemoteDebugArgumentProperty)));
                if (((property == null) 
                            && (this.GeneratedFallbackRule != null)))
                {
                    localRule = this.GeneratedFallbackRule;
                    property = ((Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty)(localRule.GetProperty(EmuliciousRemoteDebugArgumentProperty)));
                }
                return property;
            }
        }
        
        /// <summary>Uses symlink&apos;s relative to the rom path to map all the &apos;Source Folder Paths&apos;.</summary>
        internal Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty EmuliciousLegacySourceFolders
        {
            get
            {
                Microsoft.VisualStudio.ProjectSystem.Properties.IRule localRule = this.rule;
                if ((localRule == null))
                {
                    localRule = this.GeneratedFallbackRule;
                }
                if ((localRule == null))
                {
                    return null;
                }
                Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty property = ((Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty)(localRule.GetProperty(EmuliciousLegacySourceFoldersProperty)));
                if (((property == null) 
                            && (this.GeneratedFallbackRule != null)))
                {
                    localRule = this.GeneratedFallbackRule;
                    property = ((Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty)(localRule.GetProperty(EmuliciousLegacySourceFoldersProperty)));
                }
                return property;
            }
        }
        
        /// <summary>Injects breakpoint line information if it is not provided in breakpoint response messages.</summary>
        internal Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty EmuliciousLegacyBreakpointFix
        {
            get
            {
                Microsoft.VisualStudio.ProjectSystem.Properties.IRule localRule = this.rule;
                if ((localRule == null))
                {
                    localRule = this.GeneratedFallbackRule;
                }
                if ((localRule == null))
                {
                    return null;
                }
                Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty property = ((Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty)(localRule.GetProperty(EmuliciousLegacyBreakpointFixProperty)));
                if (((property == null) 
                            && (this.GeneratedFallbackRule != null)))
                {
                    localRule = this.GeneratedFallbackRule;
                    property = ((Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty)(localRule.GetProperty(EmuliciousLegacyBreakpointFixProperty)));
                }
                return property;
            }
        }
        
        /// <summary>Get the fallback rule if the current rule on disk is missing or a property in the rule on disk is missing</summary>
        private Microsoft.VisualStudio.ProjectSystem.Properties.IRule GeneratedFallbackRule
        {
            get
            {
                if (((this.fallbackRule == null) 
                            && (this.configuredProject != null)))
                {
                    System.Threading.Monitor.Enter(this.locker);
                    try
                    {
                        if ((this.fallbackRule == null))
                        {
                            this.InitializeFallbackRule();
                        }
                    }
                    finally
                    {
                        System.Threading.Monitor.Exit(this.locker);
                    }
                }
                return this.fallbackRule;
            }
        }
        
        private static Microsoft.VisualStudio.ProjectSystem.Properties.IRule GetRule(Microsoft.VisualStudio.ProjectSystem.Properties.IPropertyPagesCatalog catalog, string file, string itemType, string itemName)
        {
            if ((catalog == null))
            {
                return null;
            }
            return catalog.BindToContext(SchemaName, file, itemType, itemName);
        }
        
        private static string GetContextFile(Microsoft.VisualStudio.ProjectSystem.Properties.IProjectPropertiesContext propertiesContext)
        {
            if ((propertiesContext.IsProjectFile == true))
            {
                return null;
            }
            else
            {
                return propertiesContext.File;
            }
        }
        
        private void InitializeFallbackRule()
        {
            if ((this.configuredProject == null))
            {
                return;
            }
            Microsoft.Build.Framework.XamlTypes.Rule unboundRule = EmuliciousDebugger.deserializedFallbackRule;
            if ((unboundRule == null))
            {
                System.IO.Stream xamlStream = null;
                System.Reflection.Assembly thisAssembly = System.Reflection.Assembly.GetExecutingAssembly();
                try
                {
                    xamlStream = thisAssembly.GetManifestResourceStream("XamlRuleToCode:EmuliciousDebugger.xaml");
                    Microsoft.Build.Framework.XamlTypes.IProjectSchemaNode root = ((Microsoft.Build.Framework.XamlTypes.IProjectSchemaNode)(System.Xaml.XamlServices.Load(xamlStream)));
                    System.Collections.Generic.IEnumerator<System.Object> ruleEnumerator = root.GetSchemaObjects(typeof(Microsoft.Build.Framework.XamlTypes.Rule)).GetEnumerator();
                    for (
                    ; ((unboundRule == null) 
                                && ruleEnumerator.MoveNext()); 
                    )
                    {
                        Microsoft.Build.Framework.XamlTypes.Rule t = ((Microsoft.Build.Framework.XamlTypes.Rule)(ruleEnumerator.Current));
                        if (System.StringComparer.OrdinalIgnoreCase.Equals(t.Name, SchemaName))
                        {
                            unboundRule = t;
                            unboundRule.Name = "007389346d3f21e89f00885ee201490c4c28a29ed553c7db470b3350ed2329c2";
                            EmuliciousDebugger.deserializedFallbackRule = unboundRule;
                        }
                    }
                }
                finally
                {
                    if ((xamlStream != null))
                    {
                        ((System.IDisposable)(xamlStream)).Dispose();
                    }
                }
            }
            this.configuredProject.Services.AdditionalRuleDefinitions.AddRuleDefinition(unboundRule, "FallbackRuleCodeGenerationContext");
            Microsoft.VisualStudio.ProjectSystem.Properties.IPropertyPagesCatalog catalog = this.configuredProject.Services.PropertyPagesCatalog.GetMemoryOnlyCatalog("FallbackRuleCodeGenerationContext");
            this.fallbackRule = catalog.BindToContext(unboundRule.Name, this.file, this.itemType, this.itemName);
        }
    }
    
    internal partial class ProjectProperties
    {
        
        private static System.Func<System.Threading.Tasks.Task<System.Collections.Immutable.IImmutableDictionary<string, Microsoft.VisualStudio.ProjectSystem.Properties.IPropertyPagesCatalog>>, object, EmuliciousDebugger> CreateEmuliciousDebuggerPropertiesDelegate = new System.Func<System.Threading.Tasks.Task<System.Collections.Immutable.IImmutableDictionary<string, Microsoft.VisualStudio.ProjectSystem.Properties.IPropertyPagesCatalog>>, object, EmuliciousDebugger>(CreateEmuliciousDebuggerProperties);
        
        private static EmuliciousDebugger CreateEmuliciousDebuggerProperties(System.Threading.Tasks.Task<System.Collections.Immutable.IImmutableDictionary<string, Microsoft.VisualStudio.ProjectSystem.Properties.IPropertyPagesCatalog>> namedCatalogs, object state)
        {
            ProjectProperties that = ((ProjectProperties)(state));
            return new EmuliciousDebugger(that.ConfiguredProject, namedCatalogs.Result, "Project", that.File, that.ItemType, that.ItemName);
        }
        
        /// <summary>Gets the strongly-typed property accessor used to get and set Emulicious Debugger options properties.</summary>
        internal System.Threading.Tasks.Task<EmuliciousDebugger> GetEmuliciousDebuggerPropertiesAsync()
        {
            System.Threading.Tasks.Task<System.Collections.Immutable.IImmutableDictionary<string, Microsoft.VisualStudio.ProjectSystem.Properties.IPropertyPagesCatalog>> namedCatalogsTask = this.GetNamedCatalogsAsync();
            return namedCatalogsTask.ContinueWith(CreateEmuliciousDebuggerPropertiesDelegate, this, System.Threading.CancellationToken.None, System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously, System.Threading.Tasks.TaskScheduler.Default);
        }
        
        /// <summary>Gets the strongly-typed property accessor used to get value from the current project snapshot Emulicious Debugger options properties.</summary>
        internal bool TryGetCurrentEmuliciousDebuggerPropertiesSnapshot(out EmuliciousDebugger snapshot, [System.Runtime.InteropServices.OptionalAttribute()] [System.Runtime.InteropServices.DefaultParameterValueAttribute(true)] bool requiredToMatchProjectVersion)
        {
            snapshot = null;
            Microsoft.VisualStudio.ProjectSystem.IProjectVersionedValue<Microsoft.VisualStudio.ProjectSystem.Properties.IProjectCatalogSnapshot> catalogSnapshot;
            if (this.TryGetCurrentCatalogSnapshot(out catalogSnapshot))
            {
                if (requiredToMatchProjectVersion)
                {
                    if ((this.ConfiguredProject.ProjectVersion.CompareTo(catalogSnapshot.DataSourceVersions[Microsoft.VisualStudio.ProjectSystem.ProjectDataSources.ConfiguredProjectVersion]) != 0))
                    {
                        return false;
                    }
                }
                Microsoft.VisualStudio.ProjectSystem.Properties.IRule rule = this.GetSnapshotRule(catalogSnapshot.Value, "Project", EmuliciousDebugger.SchemaName);
                if ((rule != null))
                {
                    snapshot = new EmuliciousDebugger(rule, this.ConfiguredProject);
                    return true;
                }
            }
            return false;
        }
    }
}
